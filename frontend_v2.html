<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cleanify v2-alpha Control Panel</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            color: #ffffff;
            height: 100vh;
            overflow: hidden;
        }

        .control-panel {
            display: grid;
            grid-template-areas: 
                "header header header"
                "sidebar map bins-status"
                "status map bins-status";
            grid-template-columns: 350px 1fr 350px;
            grid-template-rows: 60px 1fr 120px;
            height: 100vh;
        }

        .header {
            grid-area: header;
            background: rgba(0, 0, 0, 0.3);
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 20px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .logo {
            font-size: 1.5rem;
            font-weight: bold;
            color: #4CAF50;
        }

        .system-status {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #4CAF50;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .sidebar {
            grid-area: sidebar;
            background: rgba(0, 0, 0, 0.4);
            overflow-y: auto;
            border-right: 1px solid rgba(255, 255, 255, 0.1);
        }

        .bins-status-sidebar {
            grid-area: bins-status;
            background: rgba(0, 0, 0, 0.4);
            border-left: 1px solid rgba(255, 255, 255, 0.1);
            overflow-y: auto;
            padding: 20px;
        }

        .bins-status-title {
            font-size: 1.2rem;
            font-weight: bold;
            margin-bottom: 15px;
            color: #4CAF50;
        }

        .corridor-section {
            margin-bottom: 25px;
            background: rgba(255, 165, 0, 0.1);
            border: 1px solid rgba(255, 165, 0, 0.3);
            border-radius: 8px;
            padding: 15px;
        }

        .corridor-title {
            font-size: 1rem;
            font-weight: bold;
            color: #FF9800;
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .corridor-icon {
            width: 16px;
            height: 16px;
            background: #FF9800;
            border-radius: 50%;
        }

        .corridor-stats {
            font-size: 0.8rem;
            opacity: 0.8;
            margin-bottom: 10px;
        }

        .corridor-toggle {
            margin-bottom: 15px;
        }

        .toggle-btn {
            background: rgba(255, 152, 0, 0.2);
            border: 1px solid #FF9800;
            color: #FF9800;
            padding: 5px 10px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.8rem;
            transition: all 0.3s ease;
        }

        .toggle-btn:hover {
            background: rgba(255, 152, 0, 0.3);
        }

        .toggle-btn.active {
            background: #FF9800;
            color: #000;
        }

        .bin-status-item {
            margin-bottom: 15px;
            padding: 12px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            position: relative;
        }

        .bin-status-item.corridor-bin {
            background: rgba(255, 152, 0, 0.15);
            border-color: rgba(255, 152, 0, 0.4);
        }

        .bin-status-item.corridor-bin::before {
            content: "üìç";
            position: absolute;
            top: 8px;
            right: 8px;
            font-size: 12px;
        }

        .bin-status-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }

        .bin-id {
            font-weight: bold;
            font-size: 0.9rem;
        }

        .bin-fill-percentage {
            font-size: 0.8rem;
            opacity: 0.8;
        }

        .corridor-tag {
            font-size: 0.7rem;
            background: #FF9800;
            color: #000;
            padding: 2px 6px;
            border-radius: 10px;
            margin-left: 5px;
        }

        .bin-fill-bar {
            position: relative;
            height: 30px;
            background: #333;
            border-radius: 15px;
            overflow: hidden;
            border: 2px solid rgba(255, 255, 255, 0.2);
        }

        .bin-fill-level {
            position: absolute;
            left: 0;
            top: 0;
            height: 100%;
            background: linear-gradient(90deg, #ff4444, #ff6666);
            transition: width 0.3s ease;
            border-radius: 13px 0 0 13px;
        }

        .bin-overflow-area {
            position: absolute;
            right: 0;
            top: 0;
            width: 20%;
            height: 100%;
            background: rgba(128, 128, 128, 0.3);
            border-radius: 0 13px 13px 0;
        }

        .bin-fill-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 0.75rem;
            font-weight: bold;
            color: white;
            text-shadow: 0 1px 2px rgba(0,0,0,0.8);
            z-index: 10;
        }

        .bin-details {
            margin-top: 8px;
            font-size: 0.75rem;
            opacity: 0.8;
        }

        .bin-detail-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 2px;
        }

        .hourly-rate-indicator {
            display: inline-block;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            margin-left: 5px;
        }

        .rate-low { background: #4CAF50; }
        .rate-medium { background: #FFC107; }
        .rate-high { background: #FF9800; }
        .rate-critical { background: #F44336; }

        .map-container {
            grid-area: map;
            position: relative;
        }

        #map {
            width: 100%;
            height: 100%;
        }

        .map-controls {
            position: absolute;
            top: 10px;
            right: 10px;
            z-index: 1000;
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .map-control-btn {
            background: rgba(0, 0, 0, 0.7);
            color: white;
            border: none;
            padding: 8px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.8rem;
            transition: background 0.3s ease;
        }

        .map-control-btn:hover {
            background: rgba(0, 0, 0, 0.9);
        }

        .map-control-btn.active {
            background: #FF9800;
            color: #000;
        }

        .status-bar {
            grid-area: status;
            background: rgba(0, 0, 0, 0.4);
            padding: 20px;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 0.85rem;
        }

        .connection-status {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .loading-spinner {
            width: 16px;
            height: 16px;
            border: 2px solid #333;
            border-top: 2px solid #4CAF50;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            display: none;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .sidebar-section {
            padding: 20px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .section-title {
            font-size: 1.1rem;
            font-weight: bold;
            margin-bottom: 15px;
            color: #4CAF50;
        }

        .config-upload {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .file-input-wrapper {
            position: relative;
            overflow: hidden;
            display: inline-block;
            width: 100%;
        }

        .file-input {
            position: absolute;
            left: -9999px;
        }

        .file-input-button {
            display: block;
            padding: 10px 15px;
            background: rgba(76, 175, 80, 0.2);
            border: 2px dashed #4CAF50;
            border-radius: 5px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 0.9rem;
        }

        .file-input-button:hover {
            background: rgba(76, 175, 80, 0.3);
        }

        .btn {
            padding: 8px 16px;
            background: #4CAF50;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.9rem;
            transition: background 0.3s ease;
        }

        .btn:hover {
            background: #45a049;
        }

        .btn:disabled {
            background: #666;
            cursor: not-allowed;
        }

        .btn-secondary {
            background: #757575;
        }

        .btn-secondary:hover {
            background: #616161;
        }

        .btn-danger {
            background: #f44336;
        }

        .btn-danger:hover {
            background: #d32f2f;
        }

        .config-status {
            padding: 10px;
            border-radius: 4px;
            margin-top: 10px;
            font-size: 0.85rem;
        }

        .config-status.loading {
            background: rgba(255, 193, 7, 0.2);
            border: 1px solid #FFC107;
            color: #FFC107;
        }

        .config-status.success {
            background: rgba(76, 175, 80, 0.2);
            border: 1px solid #4CAF50;
            color: #4CAF50;
        }

        .config-status.error {
            background: rgba(244, 67, 54, 0.2);
            border: 1px solid #f44336;
            color: #f44336;
        }

        .metrics-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
        }

        .metric-card {
            background: rgba(255, 255, 255, 0.05);
            padding: 15px;
            border-radius: 8px;
            text-align: center;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .metric-value {
            font-size: 1.5rem;
            font-weight: bold;
            color: #4CAF50;
        }

        .metric-label {
            font-size: 0.8rem;
            opacity: 0.8;
            margin-top: 5px;
        }

        .simulation-controls {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
        }

        .simulation-info {
            background: rgba(255, 255, 255, 0.05);
            padding: 10px;
            border-radius: 6px;
            margin-top: 15px;
            font-size: 0.85rem;
        }

        .simulation-info div {
            margin-bottom: 5px;
        }

        .simulation-time {
            font-family: 'Courier New', monospace;
            color: #4CAF50;
        }

        .route-line {
            stroke-width: 4;
            stroke-opacity: 0.8;
            fill: none;
        }

        .route-active {
            stroke: #2196F3;
            animation: routePulse 2s infinite;
        }

        .route-completed {
            stroke: #4CAF50;
        }

        .route-planned {
            stroke: #FF9800;
            stroke-dasharray: 10, 5;
        }

        @keyframes routePulse {
            0%, 100% { stroke-opacity: 0.8; }
            50% { stroke-opacity: 1; }
        }

        .truck-marker {
            animation: truckBounce 1s ease-in-out infinite alternate;
        }

        @keyframes truckBounce {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.2); }
        }

        /* Corridor-specific styles */
        .corridor-area {
            fill-opacity: 0.15;
            stroke-opacity: 0.6;
            stroke-width: 2;
            stroke-dasharray: 5, 5;
        }

        .corridor-bin-marker {
            stroke: #FF9800;
            stroke-width: 3;
            fill-opacity: 0.7;
        }

        .regular-bin-marker {
            stroke: #fff;
            stroke-width: 2;
            fill-opacity: 0.8;
        }
    </style>
</head>
<body>
    <div class="control-panel">
        <!-- Header -->
        <div class="header">
            <div class="logo">Cleanify v2-alpha</div>
            <div class="system-status">
                <div class="status-dot" id="systemStatusDot"></div>
                <span id="systemStatusText">System Ready</span>
            </div>
        </div>

        <!-- Left Sidebar -->
        <div class="sidebar">
            <!-- Configuration Section -->
            <div class="sidebar-section">
                <div class="section-title">Configuration</div>
                <div class="config-upload">
                    <div class="file-input-wrapper">
                        <input type="file" id="configFile" class="file-input" accept=".json,.csv">
                        <label for="configFile" class="file-input-button">
                            Upload Config (JSON/CSV)
                        </label>
                    </div>
                    <button class="btn btn-secondary" onclick="loadSampleConfig()">Load Sample</button>
                    <button class="btn" onclick="exportState()" id="exportBtn" disabled>Export State</button>
                </div>
                <div id="configStatus" class="config-status loading">Ready to load configuration</div>
            </div>

            <!-- Metrics Section -->
            <div class="sidebar-section">
                <div class="section-title">System Metrics</div>
                <div class="metrics-grid">
                    <div class="metric-card">
                        <div class="metric-value" id="binCount">0</div>
                        <div class="metric-label">Bins</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-value" id="truckCount">0</div>
                        <div class="metric-label">Trucks</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-value" id="urgentBins">0</div>
                        <div class="metric-label">Urgent Bins</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-value" id="activeRoutes">0</div>
                        <div class="metric-label">Active Routes</div>
                    </div>
                </div>
            </div>

            <!-- Simulation Controls -->
            <div class="sidebar-section">
                <div class="section-title">Simulation</div>
                <div class="simulation-controls">
                    <button class="btn" onclick="startSimulation()" id="startBtn" disabled>
                        Start
                    </button>
                    <button class="btn btn-danger" onclick="pauseSimulation()" id="pauseBtn" disabled>
                        Pause
                    </button>
                </div>
                
                <div style="margin-top: 15px;">
                    <label style="font-size: 0.85rem; opacity: 0.8;">Simulation Speed</label>
                    <input type="range" id="speedSlider" min="0.5" max="25" step="0.5" value="1" 
                           style="width: 100%; margin-top: 5px;" disabled>
                    <div style="text-align: center; font-size: 0.8rem; margin-top: 5px;">
                        <span id="speedValue">1.0x</span>
                    </div>
                </div>
                
                <div class="simulation-info" id="simulationInfo">
                    <div><strong>Status:</strong> <span id="simStatus">Stopped</span></div>
                    <div><strong>Time:</strong> <span id="simTime" class="simulation-time">--:--</span></div>
                    <div><strong>Speed:</strong> <span id="simSpeed">1.0x</span></div>
                </div>

                <div style="margin-top: 15px;">
                    <button class="btn btn-secondary" onclick="triggerRoutes()" id="routeBtn" disabled>
                        Trigger Routes
                    </button>
                </div>
            </div>
        </div>

        <!-- Right Sidebar - Bins Status with Corridor -->
        <div class="bins-status-sidebar">
            <div class="bins-status-title">Bins Status</div>
            
            <!-- Corridor Section -->
            <div class="corridor-section" id="corridorSection" style="display: none;">
                <div class="corridor-title">
                    <div class="corridor-icon"></div>
                    Corridor Analysis
                </div>
                <div class="corridor-stats" id="corridorStats">
                    No active routes with corridors
                </div>
                <div class="corridor-toggle">
                    <button class="toggle-btn" id="corridorToggle" onclick="toggleCorridorVisualization()">
                        Show Corridors
                    </button>
                </div>
            </div>

            <div id="binsStatusContainer">
                <div style="text-align: center; padding: 20px; opacity: 0.6;">
                    No bins loaded
                </div>
            </div>
        </div>

        <!-- Map -->
        <div class="map-container">
            <div id="map"></div>
            <div class="map-controls">
                <button class="map-control-btn" onclick="toggleRouteLabels()">Route Labels</button>
                <button class="map-control-btn" onclick="toggleBinLabels()">Bin Labels</button>
                <button class="map-control-btn active" id="corridorMapToggle" onclick="toggleCorridorOnMap()">Corridors</button>
            </div>
        </div>

        <!-- Status Bar -->
        <div class="status-bar">
            <div class="connection-status">
                <div style="display: flex; align-items: center; gap: 8px;">
                    <div id="connectionIndicator" class="loading-spinner"></div>
                    <span id="connectionStatus">Connecting...</span>
                </div>
                <span id="lastUpdate">Never</span>
            </div>
            <div style="font-size: 0.8rem; opacity: 0.6;">
                Cleanify v2-alpha | Lahore Waste Management
            </div>
        </div>
    </div>

    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script>
        // Global variables
        let map;
        let systemState = null;
        let currentConfig = null;
        let isUpdating = false;
        let markers = new Map();
        let routes = new Map();
        let corridorAreas = new Map();
        let corridorVisible = true;
        let activeCorridorBins = new Set();
        let isUserAdjustingSpeed = false;

        const API_BASE = 'http://localhost:8000/api';

        // Initialize map
        function initMap() {
            map = L.map('map').setView([33.6844, 73.0479], 13);
            
            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: '¬© OpenStreetMap contributors'
            }).addTo(map);
        }

        // Initialize everything
        document.addEventListener('DOMContentLoaded', function() {
            initMap();
            setupEventListeners();
            startDataPolling();
        });

        function setupEventListeners() {
            // File upload
            document.getElementById('configFile').addEventListener('change', handleFileUpload);
            
            // Speed slider
            document.getElementById('speedSlider').addEventListener('input', function(e) {
                isUserAdjustingSpeed = true; // Prevent system state from overriding
                const speed = parseFloat(e.target.value);
                document.getElementById('speedValue').textContent = speed + 'x';
                
                // Clear the flag after a delay
                setTimeout(() => {
                    isUserAdjustingSpeed = false;
                }, 1000);
                
                updateSimulationSpeed(speed);
            });

        }

        function clearMarkers() {
            markers.forEach(marker => map.removeLayer(marker));
            markers.clear();
        }

        function clearRoutes() {
            routes.forEach(route => map.removeLayer(route));
            routes.clear();
        }

        function clearCorridorAreas() {
            corridorAreas.forEach(area => map.removeLayer(area));
            corridorAreas.clear();
        }

        function getFillLevelColor(fillLevel) {
            if (fillLevel >= 95) return '#F44336';
            if (fillLevel >= 85) return '#FF9800';
            if (fillLevel >= 50) return '#FFC107';
            return '#4CAF50';
        }

        function getRouteColor(status) {
            switch(status) {
                case 'active': return '#2196F3';
                case 'completed': return '#4CAF50';
                case 'planned': return '#FF9800';
                default: return '#757575';
            }
        }

        // Enhanced map update with corridor visualization
        function updateMap() {
            if (!systemState) return;

            // Clear existing markers and routes
            clearMarkers();
            clearRoutes();
            if (corridorVisible) {
                clearCorridorAreas();
            }

            // Add depot marker
            if (currentConfig && currentConfig.depot) {
                markers.set('depot', L.circleMarker([currentConfig.depot.latitude, currentConfig.depot.longitude], {
                    radius: 12,
                    fillColor: '#FF5722',
                    color: '#fff',
                    weight: 2,
                    opacity: 1,
                    fillOpacity: 0.8
                }).addTo(map).bindPopup(`<b>Depot:</b> ${currentConfig.depot.name}`));
            }

            // Add bin markers with corridor highlighting
            if (systemState.bins && Array.isArray(systemState.bins)) {
                systemState.bins.forEach((bin) => {
                    if (bin.lat && bin.lon && !isNaN(bin.lat) && !isNaN(bin.lon)) {
                        const fillLevel = bin.fill_level || 0;
                        const color = getFillLevelColor(fillLevel);
                        const isCorridorBin = activeCorridorBins.has(bin.id);
                        
                        const marker = L.circleMarker([bin.lat, bin.lon], {
                            radius: Math.max(6, 6 + (fillLevel / 100) * 4),
                            fillColor: color,
                            color: isCorridorBin ? '#FF9800' : '#fff',
                            weight: isCorridorBin ? 3 : 2,
                            opacity: 1,
                            fillOpacity: isCorridorBin ? 0.9 : 0.8,
                            className: isCorridorBin ? 'corridor-bin-marker' : 'regular-bin-marker'
                        }).addTo(map);

                        const popupContent = `
                            <b>Bin:</b> ${bin.id}<br>
                            <b>Fill Level:</b> ${fillLevel.toFixed(1)}%<br>
                            <b>Capacity:</b> ${bin.capacity_l}L<br>
                            <b>Current Rate:</b> ${bin.current_hourly_rate || bin.fill_rate_lph}L/h<br>
                            <b>Status:</b> ${fillLevel >= 95 ? 'Critical' : fillLevel >= 85 ? 'Urgent' : 'Normal'}<br>
                            ${isCorridorBin ? '<b style="color: #FF9800;">üìç Corridor Bin</b>' : ''}
                        `;
                        marker.bindPopup(popupContent);
                        markers.set(bin.id, marker);
                    }
                });
            }

            // FIXED: Add truck markers with route interpolation and debugging
            if (systemState.trucks && Array.isArray(systemState.trucks)) {
                systemState.trucks.forEach((truck) => {
                    if (truck.lat && truck.lon && !isNaN(truck.lat) && !isNaN(truck.lon)) {
                        
                        // Default position (depot)
                        let truckLat = truck.lat;
                        let truckLon = truck.lon;
                        let positionSource = "depot";
                        let routeUsed = "none";
                        
                        // Check if truck should be on route
                        const truckStatus = truck.status.toUpperCase();
                        const isOnRoute = truckStatus === 'EN_ROUTE' || truckStatus === 'COLLECTING';
                        
                        if (isOnRoute && truck.current_route_id && truck.route_progress > 0) {
                            
                            // Find route by truck_id first
                            let route = systemState.active_routes?.find(r => r.truck_id === truck.id);
                            
                            if (!route) {
                                route = systemState.active_routes?.find(r => r.id === truck.current_route_id);
                            }
                            
                            if (route && route.waypoints && route.waypoints.length > 1) {
                                routeUsed = route.id;
                                
                                // CRITICAL FIX: Check if waypoints are valid (not all same position)
                                const firstWP = route.waypoints[0];
                                const lastWP = route.waypoints[route.waypoints.length - 1];
                                const waypointsDistance = calculateDistance(
                                    firstWP.lat, firstWP.lon, 
                                    lastWP.lat, lastWP.lon
                                );
                                
                                console.log(`üîç Route ${route.id} waypoints span: ${waypointsDistance.toFixed(0)}m`);
                                
                                if (waypointsDistance > 50) {
                                    // Waypoints are valid, use normal interpolation
                                    const progress = Math.max(0.01, Math.min(0.99, truck.route_progress || 0.1));
                                    const position = interpolateRoutePosition(route.waypoints, progress);
                                    
                                    if (position) {
                                        truckLat = position.lat;
                                        truckLon = position.lon;
                                        positionSource = `route ${(progress * 100).toFixed(1)}% (valid waypoints)`;
                                        console.log(`‚úÖ Valid waypoints: Truck ${truck.id} at [${truckLat.toFixed(6)}, ${truckLon.toFixed(6)}]`);
                                    }
                                } else {
                                    // FALLBACK: Waypoints are broken, use synthetic positioning
                                    console.log(`‚ö†Ô∏è Broken waypoints detected for route ${route.id}, using fallback`);
                                    
                                    const fallbackPosition = createFallbackPosition(truck, route, truck.route_progress);
                                    if (fallbackPosition) {
                                        truckLat = fallbackPosition.lat;
                                        truckLon = fallbackPosition.lon;
                                        positionSource = `fallback ${(truck.route_progress * 100).toFixed(1)}%`;
                                        console.log(`üîÑ Fallback: Truck ${truck.id} at [${truckLat.toFixed(6)}, ${truckLon.toFixed(6)}]`);
                                    }
                                }
                            } else {
                                console.log(`‚ùå No suitable route found for truck ${truck.id}`);
                            }
                        }
                        
                        const truckIcon = createTruckIcon(truck.status);
                        
                        const marker = L.marker([truckLat, truckLon], { 
                            icon: truckIcon,
                            zIndexOffset: 1000
                        }).addTo(map);
                        
                        // Add debug marker if waypoints are broken
                        if (isOnRoute && routeUsed !== "none") {
                            const route = systemState.active_routes?.find(r => r.truck_id === truck.id);
                            if (route && route.waypoints && route.waypoints.length > 1) {
                                const firstWP = route.waypoints[0];
                                const lastWP = route.waypoints[route.waypoints.length - 1];
                                const waypointsDistance = calculateDistance(
                                    firstWP.lat, firstWP.lon, 
                                    lastWP.lat, lastWP.lon
                                );
                                
                                if (waypointsDistance <= 50) {
                                    // Add warning marker for broken waypoints
                                    const warningIcon = L.divIcon({
                                        html: '<div style="background: red; color: white; padding: 2px; border-radius: 3px; font-size: 10px;">‚ö†Ô∏è BAD WP</div>',
                                        className: 'warning-marker',
                                        iconSize: [50, 20],
                                        iconAnchor: [25, 10]
                                    });
                                    
                                    const warningMarker = L.marker([firstWP.lat, firstWP.lon], { 
                                        icon: warningIcon,
                                        zIndexOffset: 2000
                                    }).addTo(map);
                                    
                                    markers.set(`warning_${truck.id}`, warningMarker);
                                }
                            }
                        }
                        
                        marker.bindPopup(`
                            <b>Truck:</b> ${truck.id}<br>
                            <b>Status:</b> ${truck.status}<br>
                            <b>Route Used:</b> ${routeUsed}<br>
                            <b>Progress:</b> ${truck.route_progress ? (truck.route_progress * 100).toFixed(1) + '%' : 'N/A'}<br>
                            <b>Position:</b> ${positionSource}<br>
                            <b>Coords:</b> ${truckLat.toFixed(6)}, ${truckLon.toFixed(6)}
                        `);
                        
                        markers.set(`truck_${truck.id}`, marker);
                    }
                });
            }

            // Update routes with corridor visualization
            updateRoutes();
        }
        function calculateDistance(lat1, lon1, lat2, lon2) {
            const R = 6371000; // Earth's radius in meters
            const dLat = (lat2 - lat1) * Math.PI / 180;
            const dLon = (lon2 - lon1) * Math.PI / 180;
            const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
                    Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
                    Math.sin(dLon/2) * Math.sin(dLon/2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
            return R * c;
        }
        function interpolateRoutePosition(waypoints, progress) {
            if (!waypoints || waypoints.length < 2) {
                console.log('‚ùå Invalid waypoints for interpolation');
                return null;
            }
            
            // Ensure progress is between 0.01 and 0.99 to avoid edge cases
            progress = Math.max(0.01, Math.min(0.99, progress));
            
            // Find the segment
            const totalSegments = waypoints.length - 1;
            const segmentFloat = progress * totalSegments;
            const segmentIndex = Math.floor(segmentFloat);
            const segmentProgress = segmentFloat - segmentIndex;
            
            // Safety bounds
            const safeSegmentIndex = Math.max(0, Math.min(segmentIndex, totalSegments - 1));
            const start = waypoints[safeSegmentIndex];
            const end = waypoints[safeSegmentIndex + 1] || waypoints[safeSegmentIndex];
            
            // Validate waypoint structure
            if (!start.lat || !start.lon || !end.lat || !end.lon) {
                console.log('‚ùå Invalid waypoint structure:', {start, end});
                return waypoints[0];
            }
            
            // Linear interpolation
            const interpolated = {
                lat: start.lat + (end.lat - start.lat) * segmentProgress,
                lon: start.lon + (end.lon - start.lon) * segmentProgress
            };
            
            console.log(`üßÆ Interpolation: segment ${safeSegmentIndex}/${totalSegments}, progress ${segmentProgress.toFixed(3)}`);
            console.log(`üìç Result: [${interpolated.lat.toFixed(6)}, ${interpolated.lon.toFixed(6)}]`);
            
            return interpolated;
        }
        function createFallbackPosition(truck, route, progress) {
            // Create a synthetic route from depot to a bin location
            // This is a temporary fix until backend waypoints are fixed
            
            if (!route.bin_ids || route.bin_ids.length === 0) {
                return null;
            }
            
            // Find the target bin
            const targetBinId = route.bin_ids[route.bin_ids.length - 1]; // Last bin in route
            const targetBin = systemState.bins?.find(b => b.id === targetBinId);
            
            if (!targetBin) {
                return null;
            }
            
            // Create synthetic waypoints: depot -> bin
            const depotLat = 33.6844;
            const depotLon = 73.0479;
            const binLat = targetBin.lat;
            const binLon = targetBin.lon;
            
            // Linear interpolation between depot and bin
            const lat = depotLat + (binLat - depotLat) * progress;
            const lon = depotLon + (binLon - depotLon) * progress;
            
            console.log(`üéØ Fallback: ${progress * 100}% from depot [${depotLat}, ${depotLon}] to bin [${binLat}, ${binLon}]`);
            
            return { lat, lon };
        }

        // ADD: Enhanced debug function
        function debugWaypointIssues() {
            console.log('üîç WAYPOINT VALIDATION DEBUG');
            console.log('============================');
            
            const activeRoutes = systemState.active_routes || [];
            
            activeRoutes.forEach(route => {
                if (route.waypoints && route.waypoints.length > 1) {
                    const first = route.waypoints[0];
                    const last = route.waypoints[route.waypoints.length - 1];
                    const distance = calculateDistance(first.lat, first.lon, last.lat, last.lon);
                    
                    console.log(`\nüìç Route: ${route.id.substring(0, 8)}...`);
                    console.log(`   Waypoints: ${route.waypoints.length}`);
                    console.log(`   Start: [${first.lat.toFixed(6)}, ${first.lon.toFixed(6)}]`);
                    console.log(`   End: [${last.lat.toFixed(6)}, ${last.lon.toFixed(6)}]`);
                    console.log(`   Distance: ${distance.toFixed(0)}m ${distance <= 50 ? '‚ùå BROKEN' : '‚úÖ OK'}`);
                    
                    if (distance <= 50) {
                        console.log(`   üîß This route needs waypoint regeneration!`);
                    }
                }
            });
        }
        // ADD: Debug function to check route-truck alignment
        function debugRouteAlignment() {
            console.log('üîç ROUTE-TRUCK ALIGNMENT DEBUG');
            console.log('================================');
            
            if (!systemState) {
                console.log('‚ùå No system state');
                return;
            }
            
            const activeRoutes = systemState.active_routes || [];
            const trucks = systemState.trucks || [];
            
            console.log(`Routes: ${activeRoutes.length}, Trucks: ${trucks.length}`);
            
            activeRoutes.forEach(route => {
                console.log(`\nüìç Route: ${route.id}`);
                console.log(`   Truck: ${route.truck_id}`);
                console.log(`   Waypoints: ${route.waypoints?.length || 0}`);
                if (route.waypoints && route.waypoints.length > 0) {
                    console.log(`   Start: [${route.waypoints[0].lat}, ${route.waypoints[0].lon}]`);
                    console.log(`   End: [${route.waypoints[route.waypoints.length-1].lat}, ${route.waypoints[route.waypoints.length-1].lon}]`);
                }
            });
            
            trucks.forEach(truck => {
                console.log(`\nüöõ Truck: ${truck.id}`);
                console.log(`   Status: ${truck.status}`);
                console.log(`   Route ID: ${truck.current_route_id}`);
                console.log(`   Progress: ${truck.route_progress}`);
                console.log(`   Position: [${truck.lat}, ${truck.lon}]`);
                
                const matchingRoute = activeRoutes.find(r => r.truck_id === truck.id);
                console.log(`   Matching route: ${matchingRoute ? '‚úÖ Found' : '‚ùå Not found'}`);
            });
        }


        function createTruckIcon(status) {
            let color = '#757575';
            let symbol = 'üöõ';
            
            switch(status.toUpperCase()) {
                case 'IDLE': 
                    color = '#4CAF50'; 
                    symbol = 'üöõ';
                    break;
                case 'EN_ROUTE': 
                    color = '#2196F3'; 
                    symbol = 'üöõ';
                    break;
                case 'COLLECTING': 
                    color = '#FF9800'; 
                    symbol = 'üöõ';
                    break;
                case 'RETURNING': 
                    color = '#9C27B0'; 
                    symbol = 'üöõ';
                    break;
                default: 
                    color = '#757575';
                    symbol = 'üöõ';
            }
            
            return L.divIcon({
                html: `
                    <div style="
                        background: ${color}; 
                        border: 3px solid #fff; 
                        border-radius: 50%; 
                        width: 24px; 
                        height: 24px;
                        display: flex;
                        align-items: center;
                        justify-content: center;
                        font-size: 12px;
                        box-shadow: 0 2px 6px rgba(0,0,0,0.3);
                        position: relative;
                        z-index: 1000;
                    ">${symbol}</div>
                `,
                className: 'truck-marker',
                iconSize: [24, 24],
                iconAnchor: [12, 12],
                popupAnchor: [0, -12]
            });
        }
        function updateRoutes() {
            if (!systemState || !systemState.active_routes) return;

            // Clear existing routes and corridors
            clearRoutes();
            if (corridorVisible) {
                clearCorridorAreas();
            }

            // Reset corridor bins tracking
            activeCorridorBins.clear();

            console.log(`üõ£Ô∏è Frontend: Processing ${systemState.active_routes.length} active routes`);

            // Add active routes with corridors
            systemState.active_routes.forEach(route => {
                if (route.waypoints && route.waypoints.length > 1) {
                    const latlngs = route.waypoints.map(wp => [wp.lat, wp.lon]);
                    
                    console.log(`üõ£Ô∏è Frontend: Route ${route.id} has ${latlngs.length} waypoints`);
                    
                    // Draw main route
                    const polyline = L.polyline(latlngs, {
                        className: `route-line route-${route.status}`,
                        color: getRouteColor(route.status),
                        weight: 4,
                        opacity: 0.8
                    }).addTo(map);

                    // Draw corridor if enabled
                    if (corridorVisible) {
                        console.log(`üõ£Ô∏è Frontend: Drawing corridor for route ${route.id}`);
                        drawCorridorArea(route, latlngs);
                    }

                    // Track corridor bins
                    if (route.bin_ids && route.bin_ids.length > 1) {
                        // First bin is the original urgent bin, rest are corridor bins
                        route.bin_ids.slice(1).forEach(binId => {
                            activeCorridorBins.add(binId);
                        });
                        console.log(`üìç Frontend: Route ${route.id} has ${route.bin_ids.length - 1} corridor bins`);
                    }

                    polyline.bindPopup(`
                        <b>Route:</b> ${route.id}<br>
                        <b>Truck:</b> ${route.truck_id}<br>
                        <b>Status:</b> ${route.status}<br>
                        <b>Bins:</b> ${route.bin_ids ? route.bin_ids.length : 0}<br>
                        <b>Corridor Bins:</b> ${route.corridor_bins_added || 0}<br>
                        <b>Duration:</b> ${route.estimated_duration || 'N/A'}min<br>
                        <b>Progress:</b> ${route.progress ? (route.progress * 100).toFixed(1) + '%' : '0%'}
                    `);

                    routes.set(route.id, polyline);
                }
            });

            // Update corridor section visibility
            updateCorridorSection();
        }

        function drawCorridorArea(route, latlngs) {
            if (!latlngs || latlngs.length < 2) return;
            
            // Simple approach: Create overlapping circles for smoother appearance
            const corridorRadius = 250; // 250m radius
            const stepSize = Math.max(1, Math.floor(latlngs.length / 20)); // Max 20 circles per route
            
            for (let i = 0; i < latlngs.length; i += stepSize) {
                const circle = L.circle(latlngs[i], {
                    radius: corridorRadius,
                    fillColor: '#FF9800',
                    fillOpacity: 0.08, // Very transparent for overlap
                    color: '#FF9800',
                    weight: 1,
                    opacity: 0.2
                }).addTo(map);
                
                corridorAreas.set(`corridor_${route.id}_${i}`, circle);
            }
        }

        function drawSimplifiedCorridor(route, latlngs) {
            const corridorRadius = 250; // 250m radius
            
            // Draw circles at key points along the route (every 5th point)
            for (let i = 0; i < latlngs.length; i += 5) {
                const circle = L.circle(latlngs[i], {
                    radius: corridorRadius,
                    fillColor: '#FF9800',
                    fillOpacity: 0.1,
                    color: '#FF9800',
                    weight: 1,
                    opacity: 0.3
                }).addTo(map);
                
                corridorAreas.set(`corridor_${route.id}_${i}`, circle);
            }
        }

        function createRouteBuffer(latlngs, bufferMeters) {
            const bufferPolygons = [];
            
            // Convert buffer distance to approximate degrees (rough calculation)
            const bufferDegrees = bufferMeters / 111000; // ~111km per degree
            
            // Create buffer segments
            for (let i = 0; i < latlngs.length - 1; i++) {
                const start = latlngs[i];
                const end = latlngs[i + 1];
                
                // Calculate perpendicular direction for buffer
                const dx = end[1] - start[1]; // longitude difference
                const dy = end[0] - start[0]; // latitude difference
                const length = Math.sqrt(dx * dx + dy * dy);
                
                if (length === 0) continue;
                
                // Normalize and rotate 90 degrees for perpendicular
                const perpX = -dy / length * bufferDegrees;
                const perpY = dx / length * bufferDegrees;
                
                // Create buffer polygon for this segment
                const segmentBuffer = [
                    [start[0] + perpX, start[1] + perpY], // left side start
                    [end[0] + perpX, end[1] + perpY],     // left side end
                    [end[0] - perpX, end[1] - perpY],     // right side end
                    [start[0] - perpX, start[1] - perpY], // right side start
                    [start[0] + perpX, start[1] + perpY]  // close polygon
                ];
                
                bufferPolygons.push(segmentBuffer);
            }
            
            return bufferPolygons;
        }

        function updateCorridorSection() {
            const corridorSection = document.getElementById('corridorSection');
            const corridorStats = document.getElementById('corridorStats');
            
            if (!systemState || !systemState.active_routes || systemState.active_routes.length === 0) {
                corridorSection.style.display = 'none';
                return;
            }

            // Calculate corridor statistics
            let totalRoutes = systemState.active_routes.length;
            let routesWithCorridors = 0;
            let totalCorridorBins = 0;

            systemState.active_routes.forEach(route => {
                const corridorBins = route.corridor_bins_added || 0;
                if (corridorBins > 0) {
                    routesWithCorridors++;
                    totalCorridorBins += corridorBins;
                }
            });

            corridorSection.style.display = 'block';
            corridorStats.innerHTML = `
                <div>Active Routes: ${totalRoutes}</div>
                <div>Routes w/ Corridors: ${routesWithCorridors}</div>
                <div>Corridor Bins Found: ${totalCorridorBins}</div>
                <div>Efficiency Gain: ${totalCorridorBins > 0 ? ((totalCorridorBins / totalRoutes) * 100).toFixed(0) + '%' : '0%'}</div>
            `;
        }

        function updateBinsStatusSidebar() {
            const container = document.getElementById('binsStatusContainer');
            
            if (!systemState || !systemState.bins || !Array.isArray(systemState.bins)) {
                container.innerHTML = '<div style="text-align: center; padding: 20px; opacity: 0.6;">No bins loaded</div>';
                return;
            }

            let html = '';
            
            // Sort bins: urgent first, then corridor bins, then by fill level
            const sortedBins = [...systemState.bins].sort((a, b) => {
                const aUrgent = a.fill_level >= 85;
                const bUrgent = b.fill_level >= 85;
                const aCorridor = activeCorridorBins.has(a.id);
                const bCorridor = activeCorridorBins.has(b.id);
                
                if (aUrgent !== bUrgent) return bUrgent - aUrgent;
                if (aCorridor !== bCorridor) return bCorridor - aCorridor;
                return b.fill_level - a.fill_level;
            });

            sortedBins.forEach((bin) => {
                const fillLevel = bin.fill_level || 0;
                const capacityLiters = bin.capacity_l || 100;
                const currentFillLiters = (capacityLiters * fillLevel / 100).toFixed(1);
                const fillPercentage = Math.min(100, fillLevel);
                const isCorridorBin = activeCorridorBins.has(bin.id);
                
                const currentHour = systemState.current_time ? new Date(systemState.current_time).getHours() : new Date().getHours();
                const currentHourlyRate = bin.current_hourly_rate || bin.fill_rate_lph || 5.0;
                
                let rateCategory = 'rate-low';
                if (currentHourlyRate > 15) rateCategory = 'rate-critical';
                else if (currentHourlyRate > 10) rateCategory = 'rate-high';
                else if (currentHourlyRate > 5) rateCategory = 'rate-medium';
                
                const remainingCapacity = Math.max(0, capacityLiters - currentFillLiters);
                const timeToFull = remainingCapacity > 0 && currentHourlyRate > 0 ? 
                    (remainingCapacity / parseFloat(currentHourlyRate)).toFixed(1) : 0;

                html += `
                    <div class="bin-status-item ${isCorridorBin ? 'corridor-bin' : ''}">
                        <div class="bin-status-header">
                            <div class="bin-id">
                                ${bin.id}
                                ${isCorridorBin ? '<span class="corridor-tag">CORRIDOR</span>' : ''}
                            </div>
                            <div class="bin-fill-percentage">${fillLevel.toFixed(1)}%</div>
                        </div>
                        <div class="bin-fill-bar">
                            <div class="bin-fill-level" style="width: ${fillPercentage}%"></div>
                            <div class="bin-overflow-area"></div>
                            <div class="bin-fill-text">${fillLevel.toFixed(0)}%</div>
                        </div>
                        <div class="bin-details">
                            <div class="bin-detail-row">
                                <span>Capacity:</span>
                                <span>${capacityLiters}L</span>
                            </div>
                            <div class="bin-detail-row">
                                <span>Current Fill:</span>
                                <span>${currentFillLiters}L</span>
                            </div>
                            <div class="bin-detail-row">
                                <span>Hour ${currentHour} Rate:</span>
                                <span>${currentHourlyRate}L/h <div class="hourly-rate-indicator ${rateCategory}"></div></span>
                            </div>
                            <div class="bin-detail-row">
                                <span>Time to Full:</span>
                                <span>${timeToFull}h</span>
                            </div>
                        </div>
                    </div>
                `;
            });

            container.innerHTML = html;
        }

        function toggleCorridorVisualization() {
            corridorVisible = !corridorVisible;
            const btn = document.getElementById('corridorToggle');
            
            if (corridorVisible) {
                btn.textContent = 'Hide Corridors';
                btn.classList.add('active');
            } else {
                btn.textContent = 'Show Corridors';
                btn.classList.remove('active');
                clearCorridorAreas();
            }
            
            updateRoutes(); // Redraw routes with/without corridors
        }

        function toggleCorridorOnMap() {
            const btn = document.getElementById('corridorMapToggle');
            corridorVisible = !corridorVisible;
            
            if (corridorVisible) {
                btn.classList.add('active');
                btn.textContent = 'Corridors';
            } else {
                btn.classList.remove('active');
                btn.textContent = 'Corridors';
                clearCorridorAreas();
            }
            
            updateRoutes();
        }

        function toggleRouteLabels() {
            // Toggle route popup labels - implementation depends on requirements
            console.log('Toggle route labels');
        }

        function toggleBinLabels() {
            // Toggle bin popup labels - implementation depends on requirements
            console.log('Toggle bin labels');
        }

        function getTruckIcon(status) {
            return createTruckIcon(status);
        }

        // Enhanced system state update
        async function updateSystemState() {
            if (isUpdating) return;
            isUpdating = true;

            try {
                const response = await fetch(`${API_BASE}/system-state`);
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}`);
                }
                
                const newSystemState = await response.json();
                
                // Debug logging for simulation state changes
                if (systemState) {
                    const wasRunning = systemState.simulation_running;
                    const isRunning = newSystemState.simulation_running;
                    const oldSpeed = systemState.simulation_speed;
                    const newSpeed = newSystemState.simulation_speed;
                    
                    if (wasRunning !== isRunning) {
                        console.log(`üîÑ Simulation state changed: ${wasRunning} ‚Üí ${isRunning}`);
                    }
                    
                    if (oldSpeed !== newSpeed) {
                        console.log(`‚ö° Simulation speed changed: ${oldSpeed}x ‚Üí ${newSpeed}x`);
                    }
                }
                
                systemState = newSystemState;
                
                updateMetrics();
                updateSimulationInfo();
                updateMap();
                updateBinsStatusSidebar();
                
                document.getElementById('connectionStatus').textContent = 'Connected';
                document.getElementById('connectionIndicator').style.display = 'none';
                document.getElementById('lastUpdate').textContent = `Last update: ${new Date().toLocaleTimeString()}`;

            } catch (error) {
                console.error('‚ùå Frontend: System state update failed:', error);
                document.getElementById('connectionStatus').textContent = 'Connection error';
                document.getElementById('connectionIndicator').style.display = 'block';
            } finally {
                isUpdating = false;
            }
        }

        function updateMetrics() {
            if (!systemState) return;

            const binCount = systemState.bins ? systemState.bins.length : 0;
            const truckCount = systemState.trucks ? systemState.trucks.length : 0;
            const urgentBins = systemState.bins ? systemState.bins.filter(bin => bin.fill_level >= 85).length : 0;
            const activeRoutes = systemState.active_routes ? systemState.active_routes.length : 0;

            document.getElementById('binCount').textContent = binCount;
            document.getElementById('truckCount').textContent = truckCount;
            document.getElementById('urgentBins').textContent = urgentBins;
            document.getElementById('activeRoutes').textContent = activeRoutes;
        }

        function updateSimulationInfo() {
            if (!systemState) return;

            const isRunning = systemState.simulation_running || false;
            const currentTime = systemState.current_time;
            const speed = systemState.simulation_speed || 1.0;

            // Only update speed slider if user is not actively adjusting it
            if (!isUserAdjustingSpeed) {
                document.getElementById('speedSlider').value = speed;
                document.getElementById('speedValue').textContent = speed + 'x';
            }
            
            document.getElementById('simSpeed').textContent = speed + 'x';

            // Show time with seconds to see speed effect clearly
            const timeDisplay = formatSimulationTime(currentTime);
            document.getElementById('simTime').textContent = timeDisplay;
            
            // Update status with visual indicator
            const statusElement = document.getElementById('simStatus');
            if (isRunning) {
                statusElement.textContent = `Running (${speed}x)`;
                statusElement.style.color = '#4CAF50';
            } else {
                statusElement.textContent = 'Stopped';
                statusElement.style.color = '#999';
            }
            
            // Update button states
            const startBtn = document.getElementById('startBtn');
            const pauseBtn = document.getElementById('pauseBtn');
            
            if (isRunning) {
                startBtn.textContent = 'Running...';
                startBtn.disabled = true;
                pauseBtn.disabled = false;
            } else {
                startBtn.textContent = 'Start';
                startBtn.disabled = false;
                pauseBtn.disabled = true;
            }
        }


        function formatSimulationTime(timeStr) {
            if (!timeStr) return '--:--';
            try {
                const date = new Date(timeStr);
                return date.toLocaleTimeString('en-US', { 
                    hour12: false, 
                    hour: '2-digit', 
                    minute: '2-digit',
                    second: '2-digit'  // Add seconds to see speed effect
                });
            } catch (e) {
                return '--:--:--';
            }
        }

        function startDataPolling() {
            updateSystemState();
            setInterval(updateSystemState, 1000); // Update every 1 second instead of 2
        }

        // Configuration management functions
        async function handleFileUpload(event) {
            const file = event.target.files[0];
            if (!file) return;

            const statusElement = document.getElementById('configStatus');
            statusElement.textContent = 'Uploading configuration...';
            statusElement.className = 'config-status loading';

            try {
                const fileContent = await file.text();
                let config;

                if (file.name.endsWith('.json')) {
                    config = JSON.parse(fileContent);
                } else if (file.name.endsWith('.csv')) {
                    // Simple CSV parsing for bins
                    config = parseCSVToConfig(fileContent);
                } else {
                    throw new Error('Unsupported file type. Use JSON or CSV.');
                }

                // Use the CORRECT API endpoint
                const response = await fetch(`${API_BASE}/load-config`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(config)
                });

                if (!response.ok) {
                    throw new Error(`Upload failed: ${response.status}`);
                }

                const result = await response.json();
                currentConfig = config;

                statusElement.textContent = `Configuration loaded: ${result.bins || 0} bins, ${result.trucks || 0} trucks`;
                statusElement.className = 'config-status success';

                // Enable controls
                enableControls();

                // Fit map to data bounds if available
                if (config.bins && config.bins.length > 0) {
                    const group = new L.featureGroup();
                    config.bins.forEach(bin => {
                        if (bin.latitude && bin.longitude) {
                            group.addLayer(L.marker([bin.latitude, bin.longitude]));
                        }
                    });
                    if (group.getLayers().length > 0) {
                        map.fitBounds(group.getBounds().pad(0.1));
                    }
                }

            } catch (error) {
                statusElement.textContent = `Error: ${error.message}`;
                statusElement.className = 'config-status error';
            }
        }

        async function loadSampleConfig() {
            const statusElement = document.getElementById('configStatus');
            statusElement.textContent = 'Loading sample configuration...';
            statusElement.className = 'config-status loading';

            try {
                // Create sample config in frontend (no backend endpoint needed)
                const sampleConfig = {
                    depot: {
                        name: "Central Depot Lahore",
                        latitude: 33.6844,
                        longitude: 73.0479
                    },
                    trucks: [
                        {
                            id: "T001",
                            name: "Alpha Truck",
                            capacity_l: 5000,
                            lat: 33.6844,
                            lon: 73.0479
                        },
                        {
                            id: "T002", 
                            name: "Beta Truck",
                            capacity_l: 7000,
                            lat: 33.6844,
                            lon: 73.0479
                        },
                        {
                            id: "T003",
                            name: "Gamma Truck", 
                            capacity_l: 6000,
                            lat: 33.6844,
                            lon: 73.0479
                        },
                        {
                            id: "T004",
                            name: "Delta Truck",
                            capacity_l: 5500,
                            lat: 33.6844,
                            lon: 73.0479
                        },
                        {
                            id: "T005",
                            name: "Echo Truck",
                            capacity_l: 6500,
                            lat: 33.6844,
                            lon: 73.0479
                        }
                    ],
                    bins: [
                        {
                            id: "SB01",
                            latitude: 33.6854,
                            longitude: 73.0489,
                            capacity_l: 120,
                            fill_level: 75.5,
                            fill_rate_lph: 4.2
                        },
                        {
                            id: "SB02",
                            latitude: 33.6834,
                            longitude: 73.0469,
                            capacity_l: 100,
                            fill_level: 45.2,
                            fill_rate_lph: 2.8
                        },
                        {
                            id: "SB03",
                            latitude: 33.6874,
                            longitude: 73.0499,
                            capacity_l: 150,
                            fill_level: 88.7,
                            fill_rate_lph: 6.1
                        },
                        {
                            id: "SB04",
                            latitude: 33.6804,
                            longitude: 73.0459,
                            capacity_l: 120,
                            fill_level: 62.3,
                            fill_rate_lph: 5.5
                        },
                        {
                            id: "SB05",
                            latitude: 33.6884,
                            longitude: 73.0509,
                            capacity_l: 100,
                            fill_level: 67.8,
                            fill_rate_lph: 3.9
                        },
                        {
                            id: "SB06",
                            latitude: 33.6814,
                            longitude: 73.0449,
                            capacity_l: 110,
                            fill_level: 55.4,
                            fill_rate_lph: 4.8
                        },
                        {
                            id: "SB07",
                            latitude: 33.6894,
                            longitude: 73.0519,
                            capacity_l: 130,
                            fill_level: 72.1,
                            fill_rate_lph: 5.2
                        },
                        {
                            id: "SB08",
                            latitude: 33.6824,
                            longitude: 73.0439,
                            capacity_l: 105,
                            fill_level: 41.6,
                            fill_rate_lph: 3.1
                        },
                        {
                            id: "SB09",
                            latitude: 33.6864,
                            longitude: 73.0529,
                            capacity_l: 115,
                            fill_level: 78.9,
                            fill_rate_lph: 6.3
                        },
                        {
                            id: "SB10",
                            latitude: 33.6794,
                            longitude: 73.0429,
                            capacity_l: 125,
                            fill_level: 59.7,
                            fill_rate_lph: 4.5
                        },
                        {
                            id: "SB11",
                            latitude: 33.6904,
                            longitude: 73.0539,
                            capacity_l: 140,
                            fill_level: 83.2,
                            fill_rate_lph: 7.1
                        },
                        {
                            id: "SB12",
                            latitude: 33.6784,
                            longitude: 73.0419,
                            capacity_l: 95,
                            fill_level: 38.4,
                            fill_rate_lph: 2.9
                        },
                        {
                            id: "SB13",
                            latitude: 33.6914,
                            longitude: 73.0549,
                            capacity_l: 160,
                            fill_level: 91.5,
                            fill_rate_lph: 8.4
                        },
                        {
                            id: "SB14",
                            latitude: 33.6774,
                            longitude: 73.0409,
                            capacity_l: 108,
                            fill_level: 46.8,
                            fill_rate_lph: 3.6
                        },
                        {
                            id: "SB15",
                            latitude: 33.6924,
                            longitude: 73.0559,
                            capacity_l: 135,
                            fill_level: 76.3,
                            fill_rate_lph: 6.8
                        },
                        {
                            id: "SB16",
                            latitude: 33.6764,
                            longitude: 73.0399,
                            capacity_l: 118,
                            fill_level: 52.1,
                            fill_rate_lph: 4.1
                        },
                        {
                            id: "SB17",
                            latitude: 33.6934,
                            longitude: 73.0569,
                            capacity_l: 145,
                            fill_level: 87.6,
                            fill_rate_lph: 7.9
                        },
                        {
                            id: "SB18",
                            latitude: 33.6754,
                            longitude: 73.0389,
                            capacity_l: 102,
                            fill_level: 34.7,
                            fill_rate_lph: 2.5
                        },
                        {
                            id: "SB19",
                            latitude: 33.6944,
                            longitude: 73.0579,
                            capacity_l: 155,
                            fill_level: 94.8,
                            fill_rate_lph: 9.2
                        },
                        {
                            id: "SB20",
                            latitude: 33.6744,
                            longitude: 73.0379,
                            capacity_l: 112,
                            fill_level: 58.9,
                            fill_rate_lph: 4.4
                        }
                    ]
                };

                // Send to CORRECT API endpoint
                const response = await fetch(`${API_BASE}/load-config`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(sampleConfig)
                });

                if (!response.ok) {
                    throw new Error(`Failed to load sample: ${response.status}`);
                }

                const result = await response.json();
                currentConfig = sampleConfig;

                statusElement.textContent = `Sample loaded: ${result.bins || 0} bins, ${result.trucks || 0} trucks`;
                statusElement.className = 'config-status success';

                enableControls();

                // Fit map to Lahore area
                map.setView([33.6844, 73.0479], 13);

            } catch (error) {
                statusElement.textContent = `Error: ${error.message}`;
                statusElement.className = 'config-status error';
            }
        }

        function enableControls() {
            document.getElementById('startBtn').disabled = false;
            document.getElementById('pauseBtn').disabled = false;
            document.getElementById('speedSlider').disabled = false;
            document.getElementById('exportBtn').disabled = false;
            document.getElementById('routeBtn').disabled = false;
        }

        // Simulation control functions
        async function startSimulation() {
            const startBtn = document.getElementById('startBtn');
            const originalText = startBtn.textContent;
            
            try {
                startBtn.textContent = 'Starting...';
                startBtn.disabled = true;
                
                console.log('üöÄ Frontend: Sending start simulation request');
                
                const response = await fetch(`${API_BASE}/simulation/start`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' }
                });

                console.log('üì° Frontend: Start simulation response status:', response.status);
                
                if (!response.ok) {
                    const errorText = await response.text();
                    throw new Error(`HTTP ${response.status}: ${errorText}`);
                }
                
                const result = await response.json();
                console.log('‚úÖ Frontend: Start simulation result:', result);
                
                if (result.status === 'simulation_started' || result.status === 'success') {
                    console.log('‚úÖ Frontend: Simulation started successfully');
                    document.getElementById('simStatus').textContent = 'Running';
                    startBtn.textContent = 'Running...';
                    document.getElementById('pauseBtn').disabled = false;
                    
                    // Force immediate system state update
                    setTimeout(updateSystemState, 500);
                } else {
                    throw new Error(result.message || 'Unknown error starting simulation');
                }
                
            } catch (error) {
                console.error('‚ùå Frontend: Failed to start simulation:', error);
                alert(`Failed to start simulation: ${error.message}`);
                
                // Reset button
                startBtn.textContent = originalText;
                startBtn.disabled = false;
            }
        }

        async function pauseSimulation() {
            const pauseBtn = document.getElementById('pauseBtn');
            const originalText = pauseBtn.textContent;
            
            try {
                pauseBtn.textContent = 'Pausing...';
                pauseBtn.disabled = true;
                
                console.log('‚è∏Ô∏è Frontend: Sending pause simulation request');
                
                const response = await fetch(`${API_BASE}/simulation/pause`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' }
                });

                console.log('üì° Frontend: Pause simulation response status:', response.status);
                
                if (!response.ok) {
                    const errorText = await response.text();
                    throw new Error(`HTTP ${response.status}: ${errorText}`);
                }
                
                const result = await response.json();
                console.log('‚úÖ Frontend: Pause simulation result:', result);
                
                if (result.status === 'simulation_paused' || result.status === 'success') {
                    console.log('‚úÖ Frontend: Simulation paused successfully');
                    document.getElementById('simStatus').textContent = 'Paused';
                    document.getElementById('startBtn').textContent = 'Start';
                    document.getElementById('startBtn').disabled = false;
                    pauseBtn.disabled = true;
                    
                    // Force immediate system state update
                    setTimeout(updateSystemState, 500);
                } else {
                    throw new Error(result.message || 'Unknown error pausing simulation');
                }
                
            } catch (error) {
                console.error('‚ùå Frontend: Failed to pause simulation:', error);
                alert(`Failed to pause simulation: ${error.message}`);
                
                // Reset button
                pauseBtn.textContent = originalText;
                pauseBtn.disabled = false;
            }
        }

        async function updateSimulationSpeed(speed) {
            try {
                console.log(`‚ö° Frontend: Setting simulation speed to ${speed}x`);
                
                const response = await fetch(`${API_BASE}/simulation/speed`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ 
                        speed: speed,
                        multiplier: speed  // Some backends might expect 'multiplier' instead
                    })
                });
                
                if (!response.ok) {
                    const errorText = await response.text();
                    console.error(`‚ùå Frontend: Speed update failed: ${response.status} ${errorText}`);
                    return;
                }
                
                const result = await response.json();
                console.log('‚úÖ Frontend: Speed update result:', result);
                
                if (result.status === 'speed_updated' || result.status === 'success') {
                    console.log(`‚úÖ Frontend: Speed successfully set to ${result.new_speed || speed}x`);
                }
                
            } catch (error) {
                console.error('‚ùå Frontend: Failed to update speed:', error);
            }
        }

        async function triggerRoutes() {
            const routeBtn = document.getElementById('routeBtn');
            const originalText = routeBtn.textContent;
            
            try {
                routeBtn.textContent = 'Triggering...';
                routeBtn.disabled = true;
                
                console.log('üéØ Frontend: Triggering route planning');
                
                // Try the specific routes trigger endpoint
                const response = await fetch(`${API_BASE}/routes/trigger`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' }
                });

                if (!response.ok) {
                    // Fallback to dispatch endpoint if routes/trigger doesn't exist
                    const fallbackResponse = await fetch(`${API_BASE}/dispatch/plan`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' }
                    });
                    
                    if (!fallbackResponse.ok) {
                        throw new Error(`HTTP ${response.status}: ${await response.text()}`);
                    }
                    
                    const result = await fallbackResponse.json();
                    console.log('‚úÖ Frontend: Route trigger result (fallback):', result);
                } else {
                    const result = await response.json();
                    console.log('‚úÖ Frontend: Route trigger result:', result);
                }
                
                // Show success feedback
                routeBtn.textContent = 'Triggered!';
                setTimeout(() => {
                    routeBtn.textContent = originalText;
                    routeBtn.disabled = false;
                }, 2000);
                
                // Force immediate system state update to see new routes
                setTimeout(updateSystemState, 1000);
                
            } catch (error) {
                console.error('‚ùå Frontend: Failed to trigger routes:', error);
                
                // Show error feedback
                routeBtn.textContent = 'Failed';
                setTimeout(() => {
                    routeBtn.textContent = originalText;
                    routeBtn.disabled = false;
                }, 2000);
            }
        }

        async function exportState() {
            try {
                const response = await fetch(`${API_BASE}/export-state`);
                if (!response.ok) throw new Error('Export failed');

                const blob = await response.blob();
                const url = window.URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.style.display = 'none';
                a.href = url;
                a.download = `cleanify-state-${new Date().toISOString().slice(0, 19)}.json`;
                document.body.appendChild(a);
                a.click();
                window.debugRouteAlignment = debugRouteAlignment;
                window.debugWaypointIssues = debugWaypointIssues;
                window.URL.revokeObjectURL(url);
                document.body.removeChild(a);
            } catch (error) {
                console.error('Failed to export state:', error);
            }
        }
    </script>
</body>
</html>